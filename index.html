<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Lyskâ€™s Birthday Picnic Crossword â€” Interactive</title>
  <style>
    :root { --cell: 32px; }
    * { box-sizing: border-box; }
    body { font-family: Arial, sans-serif; background:#f9f9f9; margin:0; padding:24px; }
    h1 { text-align:center; margin: 0 0 12px; }
    .wrap { max-width: 980px; margin: 0 auto; background:#fff; padding:16px; border-radius:12px; box-shadow: 0 4px 16px rgba(0,0,0,0.06); }
    .controls { display:flex; gap:8px; flex-wrap:wrap; justify-content:center; margin:10px 0 18px; }
    button { padding:8px 12px; border-radius:8px; border:1px solid #ddd; background:#fafafa; cursor:pointer; }
    button:hover { background:#f0f0f0; }
    .grid { display:inline-grid; grid-auto-rows: var(--cell); grid-auto-columns: var(--cell); border:1px solid #000; }
    .cell { width: var(--cell); height: var(--cell); border-right:1px solid #000; border-bottom:1px solid #000; position:relative; }
    .cell.last-col { border-right: none; }
    .cell.last-row { border-bottom: none; }
    .num { position:absolute; top:2px; left:3px; font-size:10px; color:#111; }
    .blocked { background:#000; }
    .cell-input { position:absolute; inset:0; width:100%; height:100%; border:none; background:transparent; text-transform:uppercase; text-align:center; font: 700 18px/1 Arial, sans-serif; outline:none; }
    .cell-input:disabled { background:transparent; color:#000; }
    .cell.correct .cell-input { background: rgba(0,200,0,0.12); }
    .cell.incorrect .cell-input { background: rgba(255,0,0,0.12); }
    .cell-input::placeholder { color:transparent; }
    .cols { display:flex; gap:24px; margin-top:16px; }
    .col { flex:1; }
    .clue { margin: 4px 0; }
    .legend { text-align:center; margin-top: 16px; color:#555; font-size: 12px; }
    @media print { body { background:#fff; padding:0; } .wrap { box-shadow:none; border:none; padding:0; } .controls { display:none; } .legend { page-break-before: avoid; } .cell-input { pointer-events:none; } }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>ðŸŽ‰ Lyskâ€™s Birthday Picnic Crossword â€” Interactive ðŸŽ‰</h1>
    <div class="controls">
      <button id="toggleAnswers">Show Answers</button>
      <button id="rebuild">Rebuild</button>
      <button id="check">Check</button>
      <button id="clear">Clear</button>
      <button onclick="window.print()">Print / Save as PDF</button>
    </div>
    <div id="status" style="text-align:center; color:#666; font-size:12px; margin:-8px 0 10px"></div>
    <div id="grid" class="grid" aria-label="Crossword grid"></div>

    <div class="cols">
      <div class="col">
        <h2>Across</h2>
        <div id="across"></div>
      </div>
      <div class="col">
        <h2>Down</h2>
        <div id="down"></div>
      </div>
    </div>

    <div class="legend">Fill in each square and tap Check to highlight. Works great on phones.</div>
  </div>

  <script>
    // --- Clues & Answers ---
    const RAW_ENTRIES = [
      { clue: "Half assed festival", answer: "ELECTRICZOO" },
      { clue: "Iâ€™m going, Iâ€™m going", answer: "HESHER" },
      { clue: "stay", answer: "GOLD" },
      { clue: "I ainâ€™t dead yet (no vowels)", answer: "MTHRFCKRS" },
      { clue: "Ships", answer: "FRIENDSHIPS" },
      { clue: "How I met Julia", answer: "DRIVING" },
      { clue: "Favorite music genre", answer: "DUBSTEP" },
      { clue: "Ideal bar", answer: "APARTMENT" },
      { clue: "Favorite DJ", answer: "SPACEJAMJIMMY" },
      { clue: "Favorite people", answer: "US" },
      { clue: "Foam", answer: "DARTY" },
      { clue: "I look at all the lonely", answer: "PEOPLE" },
      { clue: "Kill the", answer: "NOISE" },
      { clue: "Best album of all time", answer: "WORLDS" },
      { clue: "Big", answer: "BOOTIE" },
      { clue: "You are a", answer: "CINEMA" },
      { clue: "Seven", answer: "LIONS" },
      { clue: "Lyskâ€™s hobby", answer: "3DPRINTING" },
      { clue: "Go", answer: "BIRDS" },
      { clue: "The clear reason for most nightsâ€™ blur", answer: "VODKA" },
      { clue: "Classic vintage and well-mannered cocktail", answer: "OLDFASHIONED" },
      { clue: "Oâ€™clock", answer: "SHOTS" },
      { clue: "Facebook music group", answer: "THETUNEUP" },
      { clue: "Old", answer: "LYME" },
      { clue: "Ultimate", answer: "FRISBEE" },
      { clue: "Break", answer: "DANCE" },
      { clue: "Joe", answer: "JACOB" },
      { clue: "Joe", answer: "MALLE" },
      { clue: "Irwin", answer: "MILLS" },
      { clue: "Punch in the face", answer: "LOVEPARK" },
      { clue: "Full-assed festival", answer: "ELECTRICFOREST" },
      { clue: "Willâ€™s favorite drug", answer: "LYSERGICACIDDIETHYLAMIDE" },
      { clue: "Took 6 years to get", answer: "PATENT" },
      { clue: "Super soaker filled with", answer: "4LOKO" },
      { clue: "Jennâ€™s favorite combo", answer: "CHEETOSANDSHROOMS" },
      { clue: "Juliaâ€™s favorite activity", answer: "SLEEPING" }
    ];

    const sanitize = s => s.toUpperCase().replace(/[^A-Z0-9]/g, "");

    // --- Generator ---
    function generate(entries, attempts = 1000) {
      // Strict connected build with crossword rules
      for (let attempt = 0; attempt < attempts; attempt++) {
        const words = entries.map((e, idx) => ({ idx, clue: e.clue, answer: sanitize(e.answer) }))
                             .sort((a,b) => b.answer.length - a.answer.length);
        const tail = words.slice(1);
        for (let i=tail.length-1;i>0;i--) { const j=(Math.random()*(i+1))|0; [tail[i],tail[j]]=[tail[j],tail[i]]; }
        const ordered = [words[0], ...tail];

        const cells = new Map();
        let minR=0,maxR=0,minC=0,maxC=0;
        const key=(r,c)=>`${r},${c}`;
        const get=(r,c)=>cells.get(key(r,c));
        const put=(r,c,ch)=>{ const k=key(r,c); const cur=cells.get(k); if(cur && cur!==ch) return false; cells.set(k,ch); if(r<minR)minR=r; if(r>maxR)maxR=r; if(c<minC)minC=c; if(c>maxC)maxC=c; return true; };

        const starts = [];

        // seed first word horizontally
        const first = ordered[0];
        for (let i=0;i<first.answer.length;i++) put(0,i,first.answer[i]);
        starts.push({ r:0, c:0, o:'H', idx:first.idx });

        const canPlace = (word,row,col,o) => {
          // boundaries
          if (o==='H') { if (get(row,col-1) || get(row,col+word.length)) return 0; }
          else { if (get(row-1,col) || get(row+word.length,col)) return 0; }
          let overlaps=0;
          for (let i=0;i<word.length;i++) {
            const rr = o==='H'? row : row+i;
            const cc = o==='H'? col+i : col;
            const cur = get(rr,cc);
            if (cur && cur !== word[i]) return 0;
            if (!cur) {
              if (o==='H') { if (get(rr-1,cc) || get(rr+1,cc)) return 0; }
              else { if (get(rr,cc-1) || get(rr,cc+1)) return 0; }
            } else overlaps++;
          }
          return overlaps; // require >=1 for connectivity
        };

        let okAll = true;
        for (let w=1; w<ordered.length && okAll; w++) {
          const obj = ordered[w];
          let best=null;
          for (const [k,ch] of cells.entries()) {
            const [cr,cc]=k.split(',').map(Number);
            for (let i=0;i<obj.answer.length;i++) {
              if (obj.answer[i]!==ch) continue;
              for (const o of ['H','V']) {
                const row=o==='H'?cr:cr-i;
                const col=o==='H'?cc-i:cc;
                const overlaps=canPlace(obj.answer,row,col,o);
                if(overlaps>=1){ if(!best || overlaps>best.overlaps) best={row,col,o,overlaps}; }
              }
            }
          }
          if(!best){ okAll=false; break; }
          for (let i=0;i<obj.answer.length;i++) {
            const rr=best.o==='H'?best.row:best.row+i;
            const cc=best.o==='H'?best.col+i:best.col;
            if(!put(rr,cc,obj.answer[i])){ okAll=false; break; }
          }
          if(okAll) starts.push({ r:best.row, c:best.col, o:best.o, idx: obj.idx });
        }
        if(!okAll) continue;

        // normalize to grid
        const rows=maxR-minR+1, cols=maxC-minC+1;
        const grid=Array.from({length:rows},()=>Array(cols).fill(null));
        for (const [k,v] of cells.entries()) { const [r,c]=k.split(',').map(Number); grid[r-minR][c-minC]=v; }

        // connectivity check
        const filled=[]; for(let r=0;r<rows;r++) for(let c=0;c<cols;c++) if(grid[r][c]) filled.push([r,c]);
        const q=[filled[0]]; const seen=new Set([`${filled[0][0]},${filled[0][1]}`]); const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
        while(q.length){ const [r,c]=q.shift(); for(const[dr,dc] of dirs){ const rr=r+dr,cc=c+dc; if(rr>=0&&rr<rows&&cc>=0&&cc<cols&&grid[rr][cc]){ const id=`${rr},${cc}`; if(!seen.has(id)){ seen.add(id); q.push([rr,cc]); } } } }
        if(seen.size!==filled.length) continue;

        // number and extract entries
        let num=1; const numbers=Array.from({length:rows},()=>Array(cols).fill(null));
        const across=[],down=[]; const has=(r,c)=>r>=0&&r<rows&&c>=0&&c<cols&&grid[r][c];
        for(let r=0;r<rows;r++){
          for(let c=0;c<cols;c++){
            if(!grid[r][c]) continue;
            const startA=!has(r,c-1)&&has(r,c+1);
            const startD=!has(r-1,c)&&has(r+1,c);
            let assigned=false;
            if(startA){ let cc=c,ans=''; while(has(r,cc)){ ans+=grid[r][cc]; cc++; } across.push({num,answer:ans,r,c,o:'H'}); assigned=true; }
            if(startD){ let rr=r,ans=''; while(has(rr,c)){ ans+=grid[rr][c]; rr++; } down.push({num,answer:ans,r,c,o:'V'}); assigned=true; }
            if(assigned) numbers[r][c]=num++;
          }
        }

        // map clues by normalized start positions
        const startKey=(r,c,o)=>`${r},${c},${o}`;
        const startMap=new Map();
        for(const s of starts) startMap.set(startKey(s.r-minR,s.c-minC,s.o), entries[s.idx].clue);
        const withClue=arr=>arr.map(it=>({ ...it, clue: startMap.get(startKey(it.r,it.c,it.o)) || '(clue missing)' }));

        return { grid, numbers, across: withClue(across), down: withClue(down) };
      }

      // Fallback greedy (always builds, keeps crossings when possible)
      const words = entries.map((e, idx) => ({ idx, clue: e.clue, answer: sanitize(e.answer) }))
                           .sort((a,b) => b.answer.length - a.answer.length);
      const cells = new Map(); let minR=0,maxR=0,minC=0,maxC=0;
      const key=(r,c)=>`${r},${c}`; const get=(r,c)=>cells.get(key(r,c));
      const put=(r,c,ch)=>{ const k=key(r,c); const cur=cells.get(k); if(cur && cur!==ch) return false; cells.set(k,ch); if(r<minR)minR=r; if(r>maxR)maxR=r; if(c<minC)minC=c; if(c>maxC)maxC=c; return true; };
      const starts=[];
      // seed
      const first=words[0]; for(let i=0;i<first.answer.length;i++) put(0,i,first.answer[i]); starts.push({r:0,c:0,o:'H',idx:first.idx});
      // place rest
      for(let w=1; w<words.length; w++){
        const obj=words[w];
        let placed=false, best=null;
        for(const [k,ch] of cells.entries()){
          const [cr,cc]=k.split(',').map(Number);
          for(let i=0;i<obj.answer.length;i++){
            if(obj.answer[i]!==ch) continue;
            for(const o of ['H','V']){
              const row=o==='H'?cr:cr-i; const col=o==='H'?cc-i:cc;
              let ok=true, overlaps=0; for(let t=0;t<obj.answer.length;t++){ const rr=o==='H'?row:row+t; const cc2=o==='H'?col+t:col; const cur=get(rr,cc2); if(cur && cur!==obj.answer[t]){ ok=false; break; } if(cur===obj.answer[t]) overlaps++; }
              if(ok && overlaps>=1){ best={row,col,o}; break; }
            }
            if(best) break;
          }
          if(best) break;
        }
        if(best){
          for(let t=0;t<obj.answer.length;t++){ const rr=best.o==='H'?best.row:best.row+t; const cc2=best.o==='H'?best.col+t:best.col; put(rr,cc2,obj.answer[t]); }
          starts.push({r:best.row,c:best.col,o:best.o,idx:obj.idx});
          placed=true;
        }
        if(!placed){
          const row=maxR+2, col=minC; for(let t=0;t<obj.answer.length;t++) put(row, col+t, obj.answer[t]);
          starts.push({r:row,c:col,o:'H',idx:obj.idx});
        }
      }
      const rows=maxR-minR+1, cols=maxC-minC+1; const grid=Array.from({length:rows},()=>Array(cols).fill(null));
      for(const [k,v] of cells.entries()){ const [r,c]=k.split(',').map(Number); grid[r-minR][c-minC]=v; }
      let num=1; const numbers=Array.from({length:rows},()=>Array(cols).fill(null)); const across=[],down=[]; const has=(r,c)=>r>=0&&r<rows&&c>=0&&c<cols&&grid[r][c];
      for(let r=0;r<rows;r++){ for(let c=0;c<cols;c++){ if(!grid[r][c]) continue; const sa=!has(r,c-1)&&has(r,c+1); const sd=!has(r-1,c)&&has(r+1,c); let assigned=false; if(sa){ let cc=c,ans=''; while(has(r,cc)){ ans+=grid[r][cc]; cc++; } across.push({num,answer:ans,r,c,o:'H'}); assigned=true; } if(sd){ let rr=r,ans=''; while(has(rr,c)){ ans+=grid[rr][c]; rr++; } down.push({num,answer:ans,r,c,o:'V'}); assigned=true; } if(assigned) numbers[r][c]=num++; } }
      const startKey=(r,c,o)=>`${r},${c},${o}`; const startMap=new Map(); for(const s of starts) startMap.set(startKey(s.r-minR,s.c-minC,s.o), entries[s.idx].clue);
      const withClue=arr=>arr.map(it=>({ ...it, clue:startMap.get(startKey(it.r,it.c,it.o)) || '(clue)' }));
      return { grid, numbers, across: withClue(across), down: withClue(down) };
    }

    // --- Rendering ---
    function renderGrid(container,grid,numbers,showLetters){
      const rows=grid.length,cols=grid[0].length;
      container.style.display='inline-grid';
      container.style.gridTemplateColumns=`repeat(${cols}, var(--cell))`;
      container.style.gridTemplateRows=`repeat(${rows}, var(--cell))`;
      container.style.border='1px solid #000';
      container.innerHTML='';
      window.__cellsOrder = []; // track inputs in tab order
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          const div=document.createElement('div');
          div.className='cell'+(c===cols-1?' last-col':'')+(r===rows-1?' last-row':'');
          const ch=grid[r][c];
          if(ch){
            if(numbers[r][c]){ const n=document.createElement('div'); n.className='num'; n.textContent=numbers[r][c]; div.appendChild(n); }
            const inp=document.createElement('input');
            inp.className='cell-input';
            inp.setAttribute('maxlength','1');
            inp.setAttribute('inputmode','latin');
            inp.dataset.r=r; inp.dataset.c=c; inp.dataset.solution=ch;
            if(showLetters){ inp.value=ch; inp.disabled=true; }
            inp.addEventListener('input', ()=>{
              const v=inp.value.toUpperCase().replace(/[^A-Z0-9]/g,'');
              inp.value=v; markCellState(inp); if(v){ focusNext(r,c); }
            });
            inp.addEventListener('keydown', (e)=>{
              const code=e.key;
              if(code==='Backspace' && !inp.value){ e.preventDefault(); focusPrev(r,c); }
              if(code==='ArrowRight'){ e.preventDefault(); focusNext(r,c); }
              if(code==='ArrowLeft'){ e.preventDefault(); focusPrev(r,c); }
              if(code==='ArrowDown'){ e.preventDefault(); focusNextRow(r,c,1); }
              if(code==='ArrowUp'){ e.preventDefault(); focusNextRow(r,c,-1); }
            });
            div.appendChild(inp);
            window.__cellsOrder.push(inp);
          } else { div.classList.add('blocked'); }
          container.appendChild(div);
        }
      }
    }

    function renderClues(aEl,dEl,across,down){
      aEl.innerHTML=''; dEl.innerHTML='';
      across.forEach(a=>{ const p=document.createElement('div'); p.className='clue'; p.textContent=`${a.num}. ${a.clue}`; aEl.appendChild(p); });
      down.forEach(d=>{ const p=document.createElement('div'); p.className='clue'; p.textContent=`${d.num}. ${d.clue}`; dEl.appendChild(p); });
    }

    // --- Helpers ---
    function markCellState(inp){
      const cell=inp.parentElement; cell.classList.remove('correct','incorrect');
      if(!inp.value) return; if(inp.value.toUpperCase()===inp.dataset.solution){ cell.classList.add('correct'); } else { cell.classList.add('incorrect'); }
    }
    function focusNext(r,c){ const arr=window.__cellsOrder||[]; const idx=arr.findIndex(i=>+i.dataset.r===r&&+i.dataset.c===c); for(let k=idx+1;k<arr.length;k++){ if(!arr[k].disabled){ arr[k].focus(); return; } } }
    function focusPrev(r,c){ const arr=window.__cellsOrder||[]; const idx=arr.findIndex(i=>+i.dataset.r===r&&+i.dataset.c===c); for(let k=idx-1;k>=0;k--){ if(!arr[k].disabled){ arr[k].focus(); return; } } }
    function focusNextRow(r,c,dir){ const arr=window.__cellsOrder||[]; let best=null,bestDist=1e9; for(const i of arr){ if(i.disabled) continue; if(+i.dataset.c===c){ const rr=+i.dataset.r; const d=(rr-r)*dir; if(d>0 && d<bestDist){ best=i; bestDist=d; } } } if(best) best.focus(); }

    // --- Wiring ---
    const gridEl = document.getElementById('grid');
    const acrossEl = document.getElementById('across');
    const downEl = document.getElementById('down');
    const statusEl = document.getElementById('status');
    const toggleBtn = document.getElementById('toggleAnswers');
    const rebuildBtn = document.getElementById('rebuild');
    const checkBtn = document.getElementById('check');
    const clearBtn = document.getElementById('clear');

    let showing=false; let current=null;

    function rebuild(){
      statusEl.textContent='Buildingâ€¦';
      setTimeout(()=>{
        const res = generate(RAW_ENTRIES);
        if(!res){ statusEl.textContent='Couldnâ€™t build a layout. Click Rebuild again.'; return; }
        current=res; statusEl.textContent='';
        renderGrid(gridEl,res.grid,res.numbers,showing);
        renderClues(acrossEl,downEl,res.across,res.down);
      }, 10);
    }

    toggleBtn.addEventListener('click',()=>{ showing=!showing; toggleBtn.textContent=showing?'Hide Answers':'Show Answers'; if(current) renderGrid(gridEl,current.grid,current.numbers,showing); });
    rebuildBtn.addEventListener('click', rebuild);
    checkBtn.addEventListener('click', ()=>{ if(!current) return; let correct=0,total=0; document.querySelectorAll('.cell-input').forEach(inp=>{ if(inp.disabled) return; total++; const good=inp.value&&inp.value.toUpperCase()===inp.dataset.solution; const cell=inp.parentElement; cell.classList.remove('correct','incorrect'); if(good){ cell.classList.add('correct'); correct++; } else if(inp.value){ cell.classList.add('incorrect'); } }); statusEl.textContent = total? `Correct: ${correct}/${total}` : ''; });
    clearBtn.addEventListener('click', ()=>{ document.querySelectorAll('.cell-input').forEach(inp=>{ if(!inp.disabled){ inp.value=''; inp.parentElement.classList.remove('correct','incorrect'); } }); const first=document.querySelector('.cell-input:not([disabled])'); if(first) first.focus(); });

    // --- Smoke Tests (console) ---
    (function runTests(){
      const res = generate(RAW_ENTRIES, 50);
      console.assert(res && Array.isArray(res.grid), 'Generator returns a grid');
      console.assert((res.across.length + res.down.length) > 0, 'Across/Down clues exist');
      const missing = [...res.across, ...res.down].filter(e => !e.clue || /(clue)/i.test(e.clue));
      if (missing.length) console.warn('Some clues could not map directly to starts:', missing.map(m=>`${m.o} ${m.r},${m.c}`));
    })();

    // initial build
    rebuild();
  </script>
</body>
</html>
